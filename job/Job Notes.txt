# Job Service Implementation Notes

## Overview
The job service manages job postings, loading sample data, and job-resume matching functionality for the AI Resume Backend.

## Files in this Directory

### 1. job_service.py
Main service class for job management operations.

### 2. load_jobs.py
Utility script for loading sample job data from CSV into database.

---

## job_service.py - Line by Line Explanation

### Imports and Initialization
```python
import csv
import os
from typing import List, Dict, Optional
from datetime import datetime
import logging
```
- csv: For reading CSV files containing job data
- os: File system operations
- typing: Type hints for better code documentation
- datetime: Date/time operations for job postings
- logging: Error and info logging

```python
from database.database_service import DatabaseService
from nlp.embedding_service import EmbeddingService
from nlp.nlp_service import NLPService
```
- DatabaseService: For persisting job data
- EmbeddingService: For creating job description embeddings
- NLPService: For extracting skills from job descriptions

```python
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
```
- Configures logging to INFO level
- Creates logger instance for this module

```python
class JobService:
    def __init__(self):
        self.db_service = DatabaseService()
        self.embedding_service = EmbeddingService()
        self.nlp_service = NLPService()
        self.init_job_database()
```
- JobService class constructor
- Initializes database, embedding, and NLP services
- Calls init_job_database() to ensure database is ready

### Database Initialization
```python
def init_job_database(self):
    """Initialize job database with sample data if empty"""
    try:
        jobs = self.get_all_jobs()
        if len(jobs) == 0:
            logger.info("Job database is empty, loading sample jobs...")
            self.load_sample_jobs()
            logger.info(f"Loaded {len(self.get_all_jobs())} sample jobs")
    except Exception as e:
        logger.error(f"Error initializing job database: {e}")
```
- Checks if job database is empty
- If empty, loads sample jobs automatically
- Handles errors gracefully with logging

### Job Operations
```python
def get_all_jobs(self) -> List[Dict]:
    """Get all job descriptions from database"""
    try:
        return self.db_service.get_all_jobs()
    except Exception as e:
        logger.error(f"Error fetching jobs: {e}")
        return []
```
- Retrieves all jobs from database
- Wraps database call in try-catch for error handling
- Returns empty list if error occurs

```python
def get_job_by_id(self, job_id: int) -> Optional[Dict]:
    """Get job by ID"""
    try:
        jobs = self.get_all_jobs()
        for job in jobs:
            if job['id'] == job_id:
                return job
        return None
    except Exception as e:
        logger.error(f"Error fetching job {job_id}: {e}")
        return None
```
- Finds specific job by ID
- Iterates through all jobs (simple approach)
- Returns None if job not found

```python
def search_jobs(self, query: str, limit: int = 10) -> List[Dict]:
    """Search jobs by title, company, or description"""
    try:
        jobs = self.get_all_jobs()
        query_lower = query.lower()
        
        filtered_jobs = []
        for job in jobs:
            if (query_lower in job['job_title'].lower() or
                query_lower in job['company'].lower() or
                query_lower in job['description'].lower()):
                filtered_jobs.append(job)
        
        return filtered_jobs[:limit]
    except Exception as e:
        logger.error(f"Error searching jobs: {e}")
        return []
```
- Searches jobs by text matching
- Case-insensitive search in title, company, description
- Limits number of results returned

### Job Matching
```python
def match_resume_to_jobs(self, resume_text: str, limit: int = 5) -> List[Dict]:
    """Match resume text against job descriptions"""
    try:
        # Generate embedding for resume text
        resume_embedding_result = self.embedding_service.generate_embedding(resume_text)
        if 'embedding' not in resume_embedding_result:
            logger.error("Failed to generate resume embedding")
            return []
        
        resume_embedding = resume_embedding_result['embedding']
        jobs = self.get_all_jobs()
        
        matches = []
        for job in jobs:
            # Calculate similarity between resume and job description
            job_description = f"{job['job_title']} {job['description']} {job.get('requirements', '')}"
            job_embedding_result = self.embedding_service.generate_embedding(job_description)
            
            if 'embedding' in job_embedding_result:
                job_embedding = job_embedding_result['embedding']
                similarity = self.embedding_service.calculate_similarity(resume_embedding, job_embedding)
                
                matches.append({
                    'job': job,
                    'similarity_score': similarity,
                    'match_reason': self._get_match_reason(resume_text, job_description)
                })
        
        # Sort by similarity score (highest first)
        matches.sort(key=lambda x: x['similarity_score'], reverse=True)
        return matches[:limit]
        
    except Exception as e:
        logger.error(f"Error matching resume to jobs: {e}")
        return []
```
- Main job matching functionality
- Generates embedding for resume text
- Compares resume against all job descriptions
- Calculates similarity scores using embedding service
- Returns top matches sorted by similarity

```python
def _get_match_reason(self, resume_text: str, job_description: str) -> str:
    """Generate reason for job match"""
    try:
        # Extract skills from both texts
        resume_skills = set(self.nlp_service.extract_skills_and_keywords(resume_text).get('SKILL', []))
        job_skills = set(self.nlp_service.extract_skills_and_keywords(job_description).get('SKILL', []))
        
        # Find common skills
        common_skills = resume_skills.intersection(job_skills)
        
        if len(common_skills) > 0:
            return f"Matched on {len(common_skills)} skills: {', '.join(list(common_skills)[:3])}"
        else:
            return "Text similarity match"
            
    except Exception as e:
        logger.error(f"Error generating match reason: {e}")
        return "Similarity match"
```
- Generates human-readable match explanation
- Extracts skills from both resume and job
- Identifies common skills for matching
- Provides context for why match was made

### Sample Data Loading
```python
def load_sample_jobs(self):
    """Load sample jobs from CSV file"""
    try:
        csv_path = 'database/sample_jobs.csv'
        if not os.path.exists(csv_path):
            logger.error(f"Sample jobs CSV not found: {csv_path}")
            return
        
        with open(csv_path, 'r', encoding='utf-8') as file:
            reader = csv.DictReader(file)
            
            for row in reader:
                job_data = {
                    'job_title': row['title'],
                    'company': row['company'],
                    'location': row['location'],
                    'description': row['description'],
                    'requirements': row['requirements'],
                    'salary_min': int(row['salary_min']),
                    'salary_max': int(row['salary_max']),
                    'job_type': row['job_type'],
                    'experience_level': row['experience_level'],
                    'posted_date': row['posted_date']
                }
                
                # Generate embedding for job description
                full_description = f"{job_data['job_title']} {job_data['description']} {job_data['requirements']}"
                embedding_result = self.embedding_service.generate_embedding(full_description)
                
                if 'embedding' in embedding_result:
                    job_data['embedding'] = embedding_result['embedding']
                    
                    # Save to database
                    self.db_service.save_job(job_data)
                    logger.info(f"Loaded job: {job_data['job_title']} at {job_data['company']}")
                
    except Exception as e:
        logger.error(f"Error loading sample jobs: {e}")
```
- Loads sample jobs from CSV file
- Processes each row and creates job data dictionary
- Generates embeddings for job descriptions
- Saves each job to database
- Logs progress and errors

---

## load_jobs.py - Line by Line Explanation

### Imports and Main Function
```python
#!/usr/bin/env python3
import csv
import json
from database.database_service import DatabaseService
from nlp.embedding_service import EmbeddingService
```
- Shebang for direct execution
- csv: Reading CSV files
- json: JSON handling (though not used in this script)
- DatabaseService and EmbeddingService imports

```python
def load_sample_jobs():
    """Load sample jobs from CSV into database"""
    print("üîÑ Loading sample jobs into database...")
```
- Main function to load sample jobs
- Prints progress message

```python
# Initialize services
db_service = DatabaseService()
embedding_service = EmbeddingService()
```
- Creates instances of required services

```python
# Create default user if not exists
from database.database_service import DatabaseService
db_service = DatabaseService()
```
- Duplicate import (could be cleaned up)
- Creates database service instance

```python
# Read sample jobs from CSV
csv_path = 'database/sample_jobs.csv'
try:
    with open(csv_path, 'r', encoding='utf-8') as file:
        reader = csv.DictReader(file)
        jobs_loaded = 0
        
        for row in reader:
            # Parse job data
            job_data = {
                'job_title': row['title'],
                'company': row['company'],
                'location': row['location'],
                'description': row['description'],
                'requirements': row['requirements'],
                'salary_min': int(row['salary_min']),
                'salary_max': int(row['salary_max']),
                'job_type': row['job_type'],
                'experience_level': row['experience_level'],
                'posted_date': row['posted_date']
            }
```
- Opens CSV file for reading
- Uses DictReader to access columns by name
- Converts each row to job data dictionary
- Parses numeric fields (salary) to integers

```python
# Generate embedding for job description
full_description = f"{job_data['job_title']} {job_data['description']} {job_data['requirements']}"
embedding_result = embedding_service.generate_embedding(full_description)
```
- Combines job title, description, and requirements
- Generates embedding using embedding service
- Creates comprehensive text representation for matching

```python
if 'embedding' in embedding_result:
    job_data['embedding'] = embedding_result['embedding']
    
    # Save to database
    job_id = db_service.save_job(job_data)
    jobs_loaded += 1
    print(f"‚úÖ Loaded: {job_data['job_title']} at {job_data['company']}")
else:
    print(f"‚ùå Failed to generate embedding for: {job_data['job_title']}")
```
- Checks if embedding was generated successfully
- Adds embedding to job data
- Saves job to database and gets ID
- Prints success/failure messages

```python
print(f"\nüéâ Successfully loaded {jobs_loaded} sample jobs!")
return jobs_loaded

except FileNotFoundError:
    print(f"‚ùå Error: Sample jobs CSV file not found at {csv_path}")
    return 0
except Exception as e:
    print(f"‚ùå Error loading jobs: {e}")
    return 0
```
- Handles file not found and other errors
- Returns count of loaded jobs
- Provides clear error messages

```python
if __name__ == '__main__':
    load_sample_jobs()
```
- Allows script to be run directly
- Calls main function when executed

## How Job Service Works

### Data Flow
1. **Initialization**: Service creates database and NLP services
2. **Sample Loading**: Automatically loads sample jobs if database is empty
3. **Job Retrieval**: Methods to get all jobs or search by criteria
4. **Matching**: Compares resume text against job descriptions using embeddings
5. **Scoring**: Calculates similarity scores and provides match reasons

### Matching Algorithm
1. **Text Processing**: Combines job title, description, and requirements
2. **Embedding Generation**: Creates vector representations of text
3. **Similarity Calculation**: Uses cosine similarity between embeddings
4. **Ranking**: Sorts jobs by similarity score
5. **Reasoning**: Provides explanation for matches based on common skills

### Key Features
- **Automatic Setup**: Loads sample data on first run
- **Flexible Search**: Search jobs by multiple criteria
- **Smart Matching**: Uses NLP and embeddings for accurate matching
- **Error Handling**: Comprehensive error handling and logging
- **Extensible**: Easy to add new job sources and matching criteria

## Usage Examples

### Basic Job Search
```python
job_service = JobService()
jobs = job_service.search_jobs("python")
for job in jobs:
    print(f"{job['job_title']} at {job['company']}")
```

### Resume-Job Matching
```python
resume_text = "Experienced Python developer with React and AWS..."
matches = job_service.match_resume_to_jobs(resume_text, limit=3)
for match in matches:
    print(f"Job: {match['job']['job_title']}")
    print(f"Score: {match['similarity_score']:.2f}")
    print(f"Reason: {match['match_reason']}")
```

### Loading Custom Jobs
```python
job_service.load_sample_jobs()  # Reload sample data
```

## Data Sources

### Sample Jobs CSV Format
```csv
title,company,location,description,requirements,salary_min,salary_max,job_type,experience_level,posted_date
Senior Python Developer,TechCorp,San Francisco CA,We are looking for...,Python, Django...,120000,180000,Full-time,Senior,2024-01-15
```

The CSV contains 25+ sample jobs across different industries and experience levels, providing realistic test data for the matching system.
